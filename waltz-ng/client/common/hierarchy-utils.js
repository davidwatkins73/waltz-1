/*
 * Waltz - Enterprise Architecture
 * Copyright (C) 2016, 2017, 2018, 2019 Waltz open source project
 * See README.md for more information
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific
 *
 */
import _ from "lodash";


/**
 *  Given a set of nodes with id and parentId constructs a 'searchStr' property for each
 *  node which is the concatenation of a specified property (attr) (or function) of all the nodes
 *  parent nodes.
 */
export function prepareSearchNodes(nodes = [],
                                   attr = "name",
                                   parentKey = "parentId") {
    const nodesById = _.keyBy(nodes, "id");

    const attrFn = _.isString(attr)
        ? n => n[attr]
        : attr;

    return _.map(nodes, n => {
        let ptr = n;
        let searchStr = "";
        const nodePath = [];
        while (ptr) {
            nodePath.push(ptr);
            searchStr += (attrFn(ptr) || "") + " ";
            const parentId = ptr[parentKey];
            ptr = nodesById[parentId];
        }
        return {
            searchStr: searchStr.toLowerCase(),
            node: n,
            nodePath
        };
    });
}


/**
 * The given `termStr` will be tokenised and
 * all nodes (given in `searchNodes`) which contain all tokens
 * will be returned (de-duped).
 *
 * Use `prepareSearchNodes` to prepare the search nodes.
 * @param termStr
 * @param searchNodes
 */
export function doSearch(termStr = "", searchNodes = []) {
    const terms = _.split(termStr.toLowerCase(), /\W+/);

    return _
        .chain(searchNodes)
        .filter(sn => {
            const noTerms = termStr.trim().length === 0;
            const allMatch = _.every(terms, t => sn.searchStr.indexOf(t) >=0);
            return noTerms || allMatch;
        })
        .flatMap("nodePath")
        .uniqBy(n => n.id)
        .value();
}


/**
 * Given data that looks like:
 *
 *    [ { id: "",  parentId: ?, ... } , .. ]
 *
 * Gives back an array of top level objects which have children
 * nested in them, the result looks something like:
 *
 *    [ id: "", parentId : ?, parent : {}?, children : [ .. ], ... },  .. ]
 *
 * @param nodes
 * @param parentsAsRefs - whether to include parent as references or simple ids
 * @returns {Array}
 */
export function populateParents(nodes, parentsAsRefs = true) {
    const byId = _.chain(_.cloneDeep(nodes))
        .map(u => _.merge(u, { children: [], parent: null }))
        .keyBy("id")
        .value();

    _.each(_.values(byId), u => {
        if (u.parentId) {
            const parent = byId[u.parentId];
            if (parent) {
                parent.children.push(u);
                u.parent = parentsAsRefs
                    ? parent
                    : parent.id;
            }
        }
    });

    return _.values(byId);
}


export function buildHierarchies(nodes, parentsAsRefs = true) {
    // only give back root element/s
    return _.reject(populateParents(nodes, parentsAsRefs), n => n.parent);
}


/**
 *
 * @param nodes
 * @param selectedNodeIds
 * @returns {*}
 */
export const reduceToSelectedNodesOnly = (nodes, selectedNodeIds = []) => {
    const byId = _.keyBy(nodes, d => d.id);
    const selectedNodesOnly = _
        .chain(selectedNodeIds)
        .map(nId => byId[nId])
        .compact()
        .value();


    const selectedWithParents = _
        .chain(selectedNodesOnly)
        .flatMap(n => _.concat([n], getParents(n, d => byId[d.parentId])))
        .uniq()
        .value();

    return selectedWithParents;
};


/**
 * Given a forest like structure (typically generated by buildHierarchies)
 * returns a flattened map object representing the hierarchical structure,
 * the map is indexed by the value returned by the keyFn.
 *
 * The second argument is a function which returns the key value for a given node
 *
 * End users should call this function without passing a third argument
 * as it is simply the accumulator used when recursing down the branches of the
 * trees.
 */
export function indexHierarchyByKey(tree = [], keyFn = n => n.id, acc = {}) {
    _.forEach(tree, node => {
        acc[keyFn(node)] = node;
        indexHierarchyByKey(node.children, keyFn, acc);
    });
    return acc;
}


export function groupHierarchyByKey(tree = [], keyFn = n => n.id, acc = {}) {
    _.forEach(tree, node => {
        const key = keyFn(node);
        const bucket = acc[key] || [];
        bucket.push(node)
        acc[key] = bucket;
        groupHierarchyByKey(node.children, keyFn, acc);
    });
    return acc;
}


export function flattenChildren(node, acc = []) {
    _.forEach(node.children || [], child => {
        acc.push(child);
        flattenChildren(child, acc);
    });
    return acc;
}


/**
 The wix tree widget does deep comparisons.
 Having parents as refs therefore blows the callstack.
 This method will replace refs with id's.
 */
export function switchToParentIds(treeData = []) {
    _.each(treeData, td => {
        td.parent = td.parent ? td.parent.id : null;
        switchToParentIds(td.children);
    });
    return treeData;
}


export function findNode(nodes = [], id) {
    const found = _.find(nodes, { id });
    if (found) return found;

    for(let i = 0; i < nodes.length; i++) {
        const f = findNode(nodes[i].children, id);
        if (f) return f;
    }

    return null;
}


/**
 *
 * @param node
 * @param getParentFn - function to resolve parent, defaults to `n => n.parent`
 * @returns {Array}
 */

export function getParents(node, getParentFn = (n) => n.parent) {
    if (! node) return [];

    let ptr = getParentFn(node);

    const result = [];

    while (ptr) {
        result.push(ptr);
        ptr = getParentFn(ptr);
    }

    return result;
}


function findLeafIds(
    nodes = [],
    idFn = d => d.id,
    pidFn = d => d.parentId)
{
    const nodeIds = _.map(nodes, idFn);
    const parentIds = _
        .chain(nodes)
        .map(pidFn)
        .compact()
        .value();

    return _.difference(nodeIds, parentIds);
}


/**
 * This basic implementation of an upward merger accumulates all the ids of a
 * nodes descendants
 * @param parent
 * @param child
 * @returns {any}
 */
const descendantIdsUpwardMerger =  (parent, child) => {
    const descendantIds = _.uniq(_.concat(
        child.descendantIds || [],
        [child.id],
        parent.descendantIds || []));

    return Object.assign({}, parent, { descendantIds });
};


/**
 * This function takes a collection of nodes and ripples data up from the leaves through to
 * all ancestor nodes.  The nature of the rippling is provided by the `merger` function.
 *
 * @param nodes - collection of nodes with parents filled in (see populateParents)
 * @param merger - function which takes a parent and a child node and returns an updated parent
 * @param idFn - function which provides the id of each node (defaults to `d => d.id`)
 * @param pidFn - function which provides the parentId of each node (defaults to `d => d.parentId`)
 */
export function mergeUpwards(
    nodes = [],
    merger = descendantIdsUpwardMerger,
    idFn = d => d.id,
    pidFn = d => d.parentId)
{
    const nodesById = _.keyBy(nodes, idFn);
    const leafIds = findLeafIds(nodes);

    _.each(leafIds, lId => {
        let child = nodesById[lId];
        let parent = nodesById[pidFn(child)];
        while(parent) {
            const updatedParent = merger(parent, child);
            nodesById[pidFn(child)] = updatedParent;
            child = updatedParent;
            parent = nodesById[pidFn(parent)];
        }
    });
    return _.values(nodesById);
}